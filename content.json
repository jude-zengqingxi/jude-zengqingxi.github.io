[{"title":"numpy.shape()","date":"2020-07-05T16:00:00.000Z","path":"2020/07/06/notes/","text":"shape 是numpy 数组中的概念x.shape=(2,1) y.shape=(1,2)z=np.dot(x,y)或者z=x.dot(y)===&gt; z.shape=(2,2) 注意：1.列表没有shape属性,数组有，可以使用np.array(list)转换为数组需要重点注意的是列表list是没有shape属性的，需要将其转换为数组，如下可以有两种表示方式b = [[1,2,3],[4,5,6],[7,8,9]]print(np.shape(b))print(np.array(b).shape) 2.np.dot(x,y)矩阵相乘 而 np.multiply(x,y)数组中的元素对应相乘 1234567891011 1. np.multiply()函数 函数作用 数组和矩阵对应位置相乘，输出与相乘数组/矩阵的大小一致 2. np.dot()函数函数作用 对于秩为1的数组，执行对应位置相乘，然后再相加； 对于秩不为1的二维数组，执行矩阵乘法运算 3. 星号（*）乘法运算函数作用 对数组执行对应位置相乘 对矩阵执行矩阵乘法运算","comments":true,"tags":[{"name":"numpy","slug":"numpy","permalink":"http://yoursite.com/tags/numpy/"}]},{"title":"研一上期末英语汉译英参考资料","date":"2020-01-02T09:23:32.374Z","path":"2020/01/02/研一上期末英语汉译英参考资料/","text":"研一上期末英语汉译英参考资料2016年12月汉译英 尽管录取标准不同，但中国大多数研究生院的学生人数多得惊人。 导师不仅鼓励学生尽量多读文献，也期望他们有自己的发现。 有创新思想的人更有可能发表学术价值高的论文。 不管你是决定读博还是就业，硕士学位决定你的未来。 Despite different admission standards,the number of students at most graduate school in China is surprisingly large. Advisors not only encourage students to read as much literature as possible,but expect them to make their own discoveries. These with innovative ideas are more likely to publish papers of high academic value. whether you decide to go on to become a doctorate student or find work, a master’s degree can shape your future. 2017年6月汉译英 中国大学生面临越来越多的来自于考试、交友和就业的压力， 十年内抑郁率翻了一番。 抑郁学生的特点是对生活失去兴趣并有自杀倾向。 女同学患抑郁的概率大约是男同学的二倍。 相关部门应认真对待学生的心态， 以确保他们心里健康。College students in China are faced with increasing pressure from tests,relationships and employment,doubling the incidence of depression over the past decade. Students with depression are characterized by disinterest in life and proneness to suicide. Girls students are about twice as vulnerable to depression as their boy counterparts. Departments concerned ought to take seriously the state of mind of students in order to ensure their mental health. 2018年1月 本科生， 尤其是大一学生， 都希望提高自己的英语表达能力。 问题是哪种教学方式效果更好。 如果老师只是照本宣科， 学生就很难对授课感兴趣。 只有使学生尽可能多地从课堂中受益， 教师才能被认为是称职的。 老师的首要任务是使学生的英语使用得更加地道准确。 Undergraduates,especially the freshman,hope to improve their ability to express themselves in English. The question is which teaching approach is more effective. Students can hardly become interested in instructions if the teacher does nothing but repeat what the textbook says. No teacher can be regarded as qualified unless students can benefit as much as possible from his or her lectures. The top priority for a teacher is to make students’s use of English more idiomatic and accurate. 2018年6月 我们的生活离不开音乐。 音乐的特殊之处在于它不分国界。 任何一种乐器， 不论是小提琴还是钢琴， 都是自我娱乐的良好手段。 而且，早期接触音乐有助于儿童的智力发育。 小学应该提高音乐课的教学质量，使更多的孩子成为热爱音乐的人。 ​ Music is indispensable to our life. What is special about music is that it knows no national boundaries. Any musical instrument, be it a violin or a piano, is a good means of self-entertainment . In addition, early exposure to music can promote children’s intellectual development. Elementary schools are to improve the teaching quality of music lessons to turn more kids into lovers of music. 模拟一 大学毕业生主要关心的事情之一就是自己的发展前景。 虽然名校毕业生成名的可能性更大，但学历并不一定能决定你的未来。 俗话说“行行出状元”。 人们已不像从前那样在乎社会地位。 从事自己喜爱的工作的人远远超过那些追求名利的人。 ​ One of the major concerns of college graduates is thier own prospects of development. Graduate of well-known schools are more likely to become well-known, but academic degrees will not neccessarily shape your future. There is a saying that people from all walks of life can become great masters. People no longer care about their social status as much as they used to. Far more people engage in jobs they enjoy than seek fame and wealth. 模拟二 人类当前面临多种挑战，其中之一就是全球变暖。 对汽车的过度依赖加速了化石燃料的枯竭，也增加了温室气体的排放。 我们被迫转向替代能源，如太阳能和核能。 减少能源消耗并不意味着生活水平的降低， 但需要更新基础设施。 我们应该学会放眼全球， 从我做起。 ​ Humanbeings are faced with various challenges,one of which is global warming. Excessive dependency on automobiles has accelerated the exhaustion of fossil fuels while increasing emissions of greenhouse gases. We are compelled to turn to alternative energy, such as solar energy and nuclear energy. Reduced comsumption of energy does not mean a lower living standard, but instead involves updating of infrastructure. We are to learn to look globally and act locally.","comments":true,"tags":[]},{"title":"c 语言实现简单的通讯录","date":"2019-12-31T07:30:54.000Z","path":"2019/12/31/ctest/","text":"通讯录的功能创建联系人、创建群组、对联系人进行增删减改、对联系人进行查找、对联系人进行排序##2.代码展示 /* 通讯录管理程序*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;conio.h&gt;#define N 1000//结构体的定义struct record{ char name[20]; //联系人姓名 char phone[20]; //联系人电话 char adress[40]; //联系人地址 char qunming[25]; //联系人所在群组（默认位置在其他） } contact[N]; int NO=0; //用于记录联系人的总个数 FILE *fp; //函数声明void mainmenu(); //主菜单void newrecord(); //新建联系人函数void showmenu(); //浏览菜单void showgroup(); //按群显示void showall(); //显示全部void searchmenu(); // 查找菜单void searchname(); // 按名字查找void searchphone(); //按电话号码查找void modifymenu(); // 修改菜单void deletemenu(); //删除菜单void newrecordmenu(); //创建菜单 void deleteall(); //删除所有联系人void deletesingle(); //删除一个联系人void deletename(); //删除联系人名字void deletephone(); //删除联系人电话号码void paixu(); //排序函数（按名字从小到大）int loadfile(); //建立文件void savefile(); //保存文件void savegroupfile(char *filename);//更新群里的内容void deletegroupOne(); //联系人退群函数 //主函数int main(){ printf(“\\n\\t\\t 欢迎使用通讯录管理系统”); loadfile(); while (1) { mainmenu(); }} //主菜单void mainmenu(){ char choice; system(“cls”); system(“color f4”); printf(“\\n\\t\\t***“); printf(“\\n 通讯录管理系统主菜单 \\n”); printf(“ |——————————-|\\n”); printf(“ | 选择[1]:创建功能菜单 |\\n”); printf(“ | 选择[2]:显示功能菜单 |\\n”); printf(“ | 选择[3]:查找功能菜单 |\\n”); printf(“ | 选择[4]:修改功能菜单 |\\n”); printf(“ | 选择[5]:删除功能菜单 |\\n”); printf(“ | 选择[6]:退出 |\\n”); printf(“ |——————————-|\\n”); printf(“\\n”); printf(“\\n\\t\\t***“); choice=getche(); switch (choice) { case ‘1’: newrecordmenu(); break; case ‘2’: showmenu(); break; case ‘3’: searchmenu();; break; case ‘4’: modifymenu(); break; case ‘5’: deletemenu(); break; case ‘6’: printf(“\\n\\n\\t\\t\\t感谢你的使用,bye bye!\\n”); exit(0); default: mainmenu(); }}// 创建模块void newrecordmenu(){ char choice; system(“cls”); system(“color f4”); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t 创建功能菜单 “); printf(“\\n\\t\\t |——————————-|”); printf(“\\n\\t\\t | 1-创建联系人 |”); printf(“\\n\\t\\t | 2-返回主菜单 |”); printf(“\\n\\t\\t |——————————-|”); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t***“); choice=getche(); switch (choice) { case ‘1’: newrecord(); break; case ‘2’: mainmenu(); break; default : mainmenu(); }} void newrecord(){ int number; printf(“\\n\\t\\t***请输入你想添加的联系人的个数”); scanf(“%d”,&amp;number); printf(“\\n\\t\\t***请依次输入%d个联系人信息 ****\\n”,number); while(number–) { printf(&quot;\\n\\t\\t输入姓名:&quot;); scanf(&quot;%s&quot;,contact[NO].name); printf(&quot;\\n\\t\\t输入电话号码:&quot;); scanf(&quot;%s&quot;,contact[NO].phone); printf(&quot;\\n\\t\\t输入家庭住址:&quot;); scanf(&quot;%s&quot;,contact[NO].adress); strcpy(contact[NO].qunming,&quot;其他&quot;); printf(&quot;\\n\\t\\t***********************************************************&quot;); NO++; savefile(); } return;} //浏览模块void showmenu(){ char choice; system(“cls”); system(“color f4”); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t 显示功能菜单 “); printf(“\\n\\t\\t |——————————-|”); printf(“\\n\\t\\t | 1-按群显示 |”); printf(“\\n\\t\\t | 2-显示全部 |”); printf(“\\n\\t\\t | 3-返回主菜单 |”); printf(“\\n\\t\\t |——————————-|”); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t***\\n”); choice=getche(); switch (choice) { case ‘1’: showgroup(); break; case ‘2’: showall(); break; case ‘3’: mainmenu(); break; default : showmenu(); }}void showall(){ int i; system(“cls”); system(“color f4”); paixu(); if(NO!=0) { printf(“\\n\\t\\t*** 以下为通讯录所有信息****\\n”); for (i=0; i&lt;NO; i++) { printf(“\\n\\t\\t———————————————“); printf(“\\n\\t\\t姓 名： %s”,contact[i].name); printf(“\\n\\t\\t联系电话： %s”,contact[i].phone); printf(“\\n\\t\\t家庭住址： %s”,contact[i].adress); printf(“\\n\\t\\t所在群位置：%s”,contact[i].qunming); printf(“\\n\\t\\t———————————————“); } printf(&quot;\\n\\t\\t*****************************************************&quot;); } else printf(&quot;\\n\\t\\t+_+通讯录中无任何纪录&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单：&quot;); getch(); return;}void showgroup(){ FILE *fp1; char qunflag[30]; char qunfile[30]; printf(“\\n\\t\\t请输入你要显示的群名(例如:亲人,朋友)：”); scanf(“%s”,qunflag); printf(&quot;\\n\\t\\t*************** 以下为(%s群)中所有信息************\\n&quot;,qunflag); for(int i=0;i&lt;NO;i++) { if(strcmp(contact[i].qunming,qunflag)==0) { printf(&quot;\\n\\t\\t---------------------------------------------&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t---------------------------------------------&quot;); printf(&quot;\\n&quot;); printf(&quot;\\n\\t\\t***********************************************************&quot;); } } savegroupfile(qunflag); printf(&quot;\\n\\t\\t是否继续查看群组?(1/0)&quot;); if (getch()==&apos;1&apos;) showgroup(); return;} //查找模块void searchmenu(){ char choice; system(“cls”); system(“color f4”); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t —————————–”); printf(“\\n\\t\\t | 查找菜单 |”); printf(“\\n\\t\\t | 1-按姓名查找 |”); printf(“\\n\\t\\t | 2-按电话查找 |”); printf(“\\n\\t\\t | 3-返回主菜单 |”); printf(“\\n\\t\\t |—————————|”); printf(“\\n\\t\\t****\\n”); //printf(“\\n\\t\\t你选择了：”); choice=getche(); switch (choice) { case ‘1’: searchname(); break; case ‘2’: searchphone(); break; case ‘3’: mainmenu(); break; }} void searchname(){ int flag=0; int i; char name[20]; printf(&quot;\\n\\t\\t***************** 按姓名查找 *******************&quot;); printf(&quot;\\n\\t\\t请输入姓名:&quot;); scanf(&quot;%s&quot;,name); for(i=0; i&lt;NO; i++) { if (strcmp(contact[i].name,name)==0) { printf(&quot;\\n\\t\\t************ 以下是您查找的联系人信息 **********&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t所在群位置：%s&quot;,contact[i].qunming); printf(&quot;\\n\\t\\t************************************************&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单：&quot;); flag=1; getch(); return; } } if(flag==0) { printf(&quot;\\n\\t\\t没有该姓名的联系人纪录&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单&quot;); getch(); return; }} void searchphone(){ int flag=0;// 判断是否查到联系人的标志 int i; char phone[20]; printf(&quot;\\n\\t\\t****************** 按电话查找 ******************&quot;); printf(&quot;\\n\\t\\t请输入电话:&quot;); scanf(&quot;%s&quot;,phone); for(i=0; i&lt;NO; i++) { if (strcmp(contact[i].phone,phone)==0) { printf(&quot;\\n\\t\\t************* 以下是您查找的联系人信息 *********&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t所在群位置：%s&quot;,contact[i].qunming); printf(&quot;\\n\\t\\t************************************************&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单：&quot;); flag++; getch(); return; } } if (flag==0) { printf(&quot;\\n\\t\\t没有该联系人信息&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单&quot;); getch(); return; }} void modifymenu(){ int flag=0; //判断是否找到联系人的标志 int i,k; char choice; char name[20]; struct record modify; //新建一个联系人结构体 system(&quot;cls&quot;); printf(&quot;\\n\\t\\t请输入您要修改的姓名:&quot;); scanf(&quot;%s&quot;,name); for(i=0; i&lt;NO; i++) { if (strcmp(contact[i].name,name)==0) { k=i; flag=1; modify=contact[i]; //保存当前要修改的联系人的信息 printf(&quot;\\n\\t\\t********** 以下是您将修改的联系人信息 **********&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t所在群位置：%s&quot;,contact[i].qunming); printf(&quot;\\n\\t\\t是否继续？(1/0)&quot;); if(getch()==&apos;0&apos;) modifymenu(); else { printf(&quot;\\n\\t\\t选择您要修改的选项:&quot;); printf(&quot;\\n\\t\\t\\t(1).姓 名&quot;); printf(&quot;\\n\\t\\t\\t(2).联系电话&quot;); printf(&quot;\\n\\t\\t\\t(3).家庭住址&quot;); printf(&quot;\\n\\t\\t\\t(4).存放群组的位置&quot;); printf(&quot;\\n\\t\\t\\t(5).返 回&quot;); choice=getch(); switch(choice) { case &apos;1&apos;: printf(&quot;\\n更改后的姓名:&quot;); //strcpy(contact[i].name,&quot;&quot;); //savefile(); //char nametemp[20]; scanf(&quot;%s&quot;,contact[i].name); strcat(contact[i].name,&quot;\\0&quot;); //strcpy(contact[i].name,nametemp); break; case &apos;2&apos;: printf(&quot;\\n更改后的联系电话:&quot;); scanf(&quot;%s&quot;,contact[i].phone); break; case &apos;3&apos;: printf(&quot;\\n更改后的家庭住址:&quot;); scanf(&quot;%s&quot;,contact[i].adress); break; case &apos;4&apos;: printf(&quot;\\n更改后的群组名(例如:亲人,同事):&quot;); scanf(&quot;%s&quot;,contact[i].qunming); savegroupfile(contact[i].qunming); break; case &apos;5&apos;: mainmenu(); break; default: modifymenu(); } printf(&quot;\\n\\t\\t您的修改结果为:&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t所在群位置：%s&quot;,contact[i].qunming); printf(&quot;\\n\\t\\t确认修改？1/0&quot;); if(getch()==&apos;0&apos;) { contact[i]=modify; //重新将原来的联系人信息拷贝到当前节点 printf(&quot;\\n\\t\\t修改未保存!&quot;); } else { printf(&quot;\\n\\t\\t 修改成功!&quot;); } savefile(); //保存联系人信息 printf(&quot;\\n\\t\\t是否继续修改?(1/0)&quot;); if (getch()==&apos;1&apos;) modifymenu(); return; } } } if (flag==0) { printf(&quot;\\n\\t\\t+_+没有该联系人的纪录&quot;); printf(&quot;\\n\\t\\t是否继续修改?(1/0)&quot;); if (getch()==&apos;1&apos;) modifymenu(); } return;} //删除模块void deletemenu(){ char choice; if(NO==0) { printf(“\\n\\t\\t对不起，文件中无任何纪录”); printf(“\\n\\t\\t按任意键返回主菜单”); getch(); return; } system(“cls”); printf(“\\n\\t\\t*** 删除菜单 ***“); printf(“\\n\\t\\t** 1-删除所有 **“); printf(“\\n\\t\\t** 2-删除单个 **“); printf(“\\n\\t\\t***** 3-将某个联系人退群 ***“); printf(“\\n\\t\\t***** 4-返回主菜单 *****“); printf(“\\n\\t\\t****“); printf(“\\n\\t\\t你选择了：”); choice=getchar(); switch(choice) { case ‘1’: deleteall(); break; case ‘2’: deletesingle(); break; case ‘4’: mainmenu(); break; case ‘3’: deletegroupOne(); break; default: deletemenu(); }} void deleteall(){ printf(“\\n\\t\\t确认删除?(1/0)”); if (getche()==’1’) { if ((fp=fopen(“联系人.txt”,”a+”))==0) { printf(“\\n\\t\\t+_+不能打开文件，删除失败”); mainmenu(); } NO=0; savefile(); printf(&quot;\\n\\t\\t所有联系人纪录已删除，按任意键返回主菜单&quot;); getch(); fclose(fp); return; } else return;}void deletesingle(){ char choice; printf(“\\n\\t\\t\\t1-按姓名删除”); printf(“\\n\\t\\t\\t2-按号码删除”); printf(“\\n\\t\\t\\t3-返回删除菜单”); printf(“\\n\\t\\t请选择：”); choice=getche(); switch (choice) { case ‘1’: deletename(); break; case ‘2’: deletephone(); break; case ‘3’: deletemenu(); break; }}void deletename(){ int i,j; int flag=0; //用于判断是否找到联系人的标志 char name[20]; printf(“\\n\\t\\t请输入要删除联系人姓名：”); scanf(“%s”,name); if(NO==0) { printf(“\\n\\t\\t对不起，文件中无任何纪录”); printf(“\\n\\t\\t按任意键返回主菜单”); getch(); return; } for (i=0; i&lt;NO; i++) { if (strcmp(contact[i].name,name)==0) { printf(“\\n\\t\\t以下是您要删除的联系人纪录：”); printf(“\\n\\t\\t姓 名： %s”,contact[i].name); printf(“\\n\\t\\t联系电话： %s”,contact[i].phone); printf(“\\n\\t\\t家庭住址： %s”,contact[i].adress); printf(“\\n\\t\\t所在群位置：%s”,contact[i].qunming); printf(“\\n\\t\\t是否删除?(1/0)”); if (getch()==’1’) { for (j=i; j&lt;NO-1; j++) contact[j]=contact[j+1]; //用后一个联系人的信息将前一个联系人的信息覆盖 NO–; flag=1; printf(“\\n\\t\\t^_^删除成功”); savefile(); savegroupfile(contact[i].qunming); printf(“\\n\\t\\t是否继续删除?(1/0)”); if (getch()==’1’) deletename(); return; } else return; } continue; } if (flag==0) { printf(“\\n\\t\\t没有该联系人的纪录”); printf(“\\n\\t\\t是否继续删除?(1/0)”); if (getch()==’1’) deletename(); return; }} void deletephone(){ int i,j; int flag=0; //用于判断是否找到联系人的标志 char phone[20]; printf(“\\n\\t\\t请输入要删除联系电话：”); scanf(“%s”,phone); if(NO==0) { printf(“\\n\\t\\t++对不起，文件中无任何纪录”); printf(“\\n\\t\\t按任意键返回主菜单”); getch(); return; } for (i=0; i&lt;NO; i++) { if (strcmp(contact[i].phone,phone)==0) { printf(“\\n\\t\\t以下是您要删除的联系人纪录：”); printf(“\\n\\t\\t姓 名： %s”,contact[i].name); printf(“\\n\\t\\t联系电话： %s”,contact[i].phone); printf(“\\n\\t\\t家庭住址： %s”,contact[i].adress); printf(“\\n\\t\\t所在群位置：%s”,contact[i].qunming); printf(“\\n\\t\\t是否删除?(1/0)”); if (getch()==’1’) { for (j=i; j&lt;NO-1; j++) contact[j]=contact[j+1]; NO–; flag=1; printf(“\\n\\t\\t^^删除成功”); savefile(); savegroupfile(contact[i].qunming); printf(“\\n\\t\\t是否继续删除?(1/0)”); if (getch()==’1’) deletephone(); return; } else return; } continue; } if (flag==0) { printf(&quot;\\n\\t\\t+_+没有该联系人的纪录&quot;); printf(&quot;\\n\\t\\t是否继续删除?(1/0)&quot;); if (getch()==&apos;1&apos;) deletephone(); return; }}void deletegroupOne(){ int i,j; int flag=0; char name[20]; printf(&quot;\\n\\t\\t请输入要退群联系人姓名：&quot;); scanf(&quot;%s&quot;,name); if(NO==0) { printf(&quot;\\n\\t\\t对不起，文件中无任何纪录&quot;); printf(&quot;\\n\\t\\t按任意键返回主菜单&quot;); getch(); return; } for (i=0; i&lt;NO;i++) { if (strcmp(contact[i].name,name)==0) { printf(&quot;\\n\\t\\t以下是您要删除的联系人纪录：&quot;); printf(&quot;\\n\\t\\t姓 名： %s&quot;,contact[i].name); printf(&quot;\\n\\t\\t联系电话： %s&quot;,contact[i].phone); printf(&quot;\\n\\t\\t家庭住址： %s&quot;,contact[i].adress); printf(&quot;\\n\\t\\t所在群位置：%s&quot;,contact[i].qunming); printf(&quot;\\n\\t\\t是否退群?(1/0)&quot;); if (getch()==&apos;1&apos;) { char namefileflag[25]; strcpy(namefileflag,contact[i].qunming); strcpy(contact[i].qunming,&quot;其他&quot;); savefile(); savegroupfile(contact[i].qunming); savegroupfile(namefileflag); printf(&quot;\\n\\t\\t^_^退群成功&quot;); flag=1; printf(&quot;\\n\\t\\t是否继续退群?(1/0)&quot;); if (getch()==&apos;1&apos;) deletegroupOne(); return; } else return; } continue; } if (flag==0) { printf(&quot;\\n\\t\\t没有该联系人的纪录&quot;); printf(&quot;\\n\\t\\t是否继续删除?(1/0)&quot;); if (getch()==&apos;1&apos;) deletegroupOne(); return; }} //排序模块void paixu(){ int i,j; struct record temp; //交换变量 for(i=0; i&lt;NO-1; i++) for(j=0; j&lt;NO-i-1; j++) { if(strcmp(contact[j].name,contact[j+1].name)&gt;0) { temp=contact[j]; contact[j]=contact[j+1]; contact[j+1]=temp; } } } // 写入文件预读取文件模块int loadfile(){ FILE *fp; if ((fp=fopen(&quot;联系人.txt&quot;,&quot;at+&quot;))==0) { printf(&quot;\\n\\t\\t\\t\\t建立失败&quot;); exit(0); } else { printf(&quot;\\n\\n\\t\\t\\t 电话簿建立成功！&quot;); } while(!feof(fp) &amp;&amp; fread(&amp;contact[NO],sizeof(struct record),1,fp)) { char c=fgetc(fp); // 用于将文件中的换行符吸收 NO++; } fclose(fp); printf(&quot;\\n\\t\\t\\t 按任意键进入主菜单&quot;); getch(); return 0;}void savegroupfile(char *filename){ FILE *fp1; char filename1[30]; strcpy(filename1,filename); strcat(filename1,”.txt”); if ((fp1=fopen(filename1,”w+”))==0) { printf(“\\n\\t\\t+_+文件打开失败!\\n”); } for(int i=0;i&lt;NO;i++) { if(strcmp(contact[i].qunming,filename)==0) { if (fwrite(&amp;contact[i],sizeof(struct record),1,fp1)!=1) { printf(&quot;\\n\\t\\t写入文件错误!\\n&quot;); } else { fputc(10,fp1); // 往文件中写入换行符，让文件中保存的内容更方便查询 } } } fclose(fp1);}void savefile(){ int i; if ((fp=fopen(“联系人.txt”,”w+”))==0) { printf(“\\n\\t\\t+_+文件打开失败!\\n”); } for (i=0; i&lt;NO; i++) { if (fwrite(&amp;contact[i],sizeof(struct record),1,fp)!=1) { printf(“\\n\\t\\t写入文件错误!\\n”); } else { fputc(10,fp); // 往文件中写入换行符，让文件中保存的内容更方便查询 } } printf(“\\n\\t\\t 已更新文件!\\n”); fclose(fp);} ##3.未解决问题 1.查找不能进行模糊查找 2.群的创建有点乱","comments":true,"tags":[{"name":"c language","slug":"c-language","permalink":"http://yoursite.com/tags/c-language/"}]},{"title":"c 语言实现简单的测试","date":"2019-12-31T07:30:54.000Z","path":"2019/12/31/test/","text":"this is a c language test123456789#include &lt;stdio.h&gt;int main()&#123; int input; printf(\"please input a number:\"); scanf(\"%d\",&amp;input); printf(\"%d\",input);&#125;","comments":true,"tags":[{"name":"c language","slug":"c-language","permalink":"http://yoursite.com/tags/c-language/"}]},{"title":"python+opencv 读取图片的大小","date":"2019-12-31T07:30:54.000Z","path":"2019/12/31/imagesize/","text":"123456789101112\"\"\"从本地读取一张图片，显示并输出图片的大小\"\"\"import cv2 as cvif __name__ == '__main__': src = cv.imread(r'E:\\pycharmproject\\imageprocessing\\testimage\\1.jpg', cv.IMREAD_ANYCOLOR) cv.imshow(\"img\",src) print(src.shape) cv.waitKey(0)","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Anaconda下配置tensorflow","date":"2019-12-31T04:20:25.000Z","path":"2019/12/31/anaconda/","text":"Anaconda 3.5.2 下安装 tensorflow 2.0 1.安装AnacondaAnaconda 是一个基于 Python 的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，装上Anaconda，就相当于把 Python 和一些如 Numpy、Pandas、Scrip、Matplotlib 等常用的库自动安装好了，使得安装比常规 Python 安装要容易。12下载地址：官网下载速度太慢，给大家推荐清华源的下载地址： https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;archive&#x2F;特别注意一点此处要勾上，否则之后还要去自己手动添加环境变量 ![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20191216213249315.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Njc1NTg3,size_16,color_FFFFFF,t_70) 2.安装tensorflow 切换下载源，加快下载速度 进入windows命令模式，创建tensorflow环境，安装python3.6： conda create –name tensorflow python=3.6 激活tensflow的tfenv环境： activate tensorflow 安装tensorflow:pip install –upgrade –ignore-installed tensorflow3.与pycharm IDE 关联 将项目的解释器选为Anaconda下tensorflow 环境中的 python.exe 即可.","comments":true,"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://yoursite.com/tags/tensorflow/"}]},{"title":"Hello World","date":"2019-12-30T08:55:24.258Z","path":"2019/12/30/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"tags":[]},{"title":"《深度学习入门：python 的理论与实现》","date":"2019-02-12T16:00:00.000Z","path":"2019/02/13/DL01/","text":"1234567891011121314151617181920212223242526《深度学习入门：python 的理论与实现》之神经网络的学习总结 一、获取训练数据和测试数据 1. 获取数据的原因：神经网络的特征在于从数据中学习，所谓“从数据中学习”，是指可以由数据自动决定权重和参数的值 2. 区分训练数据和测试数据的原因：为了正确评价自己所构建的神经网络模型的泛化能力，所谓“泛化能力”指的就是处理未被观察过的数据（不包含在训练数据中 的数据）的能力，获得泛化能力是机器学习的最终目标。 3. 仅仅使用一个数据集是无法进行正确的评价一个模型的，而且很可能导致过拟合问题。 二、定义激活函数 1.激活函数：阶跃函数（感知机使用） 、sigmoid、relu、softmax 2.激活函数可以说是从感知机通往神经网络的一条通道 3.神经网络必须使用的激活函数必须是非线性函数，因为使用线性函数的话，加深网络的层数就没有意义了，线性函数的问题在于不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络” 比如 h(x)&#x3D;cx y(x)&#x3D;h(h(h(x)))的运算对应三层神经网络可以用 y &#x3D; ax其中a&#x3D; c^3 为无隐藏层的神经网络代替。 三、定义损失函数 1.损失函数存在的意义：简单来说损失函数就是一个用来评价网络模型好坏的一个参考指标。通过损失函数来找到模型的最优权重参数;为了找到使损失函数尽可能小的地方，需要计算参数的导数（梯度），然后以这个导数为指引，逐步更新参数的值，直到最优。 2.均方误差函数、交叉熵误差函数 四、数值微分+梯度 1.数值微分：求损失函数某一点的导数（注意考虑偏导数的情况） 2.梯度：当我们求得损失函数某一点的导数（梯度）时，通过判断导数的正负，结合学习率（可以理解为每次移动的步幅）来移动；结合需求，按需使用梯度下降和梯度上升法。 五、学习算法的构建与实现 1.步骤： 1 mini-batch 2 计算梯度 3 更新参数 4 重复","comments":true,"tags":[{"name":"DeepLearning","slug":"DeepLearning","permalink":"http://yoursite.com/tags/DeepLearning/"}]}]